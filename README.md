# UserManagementAPI
**პროექტი დაწერილია .NET8-ზე, Clean Architecture-ით, იყენებს Repository და Unit of Work პატერნებს**

## Identity

მთელი User Management სისტემა აწყობილია ხელით, არ არის გამოყენებული IdentityServer ან Keycloak რადგან ასეთი სოლუშენისთვის overkill იქნებოდა და ის ბენეფიტები, რასაც ისინი გვთავაზობენ უმეტესწილად არ გვჭირდება.
რაც შეეხება ASP.NET Identity-ს, თავიდან მისი გამოყენებით დავიწყე წერა, თუმცა შემდეგ მივხვდი რომ არ გამომადგებოდა, რადგან ამ დავალების მთელ ბიზნეს ლოგიკას ფარავს და თვითონვე განაგებს ტრანზაქციულობას,
რეალურად არც რეპოზიტორიები დამჭირდებოდა, არც UnitOfWork.

## არქიტექტურა და პატერნების იმპლემენტაცია

სოლუშენში არქიტექტურაში მიდგომა არის ასეთი - Application ლეიერში აღწერილია ბიზნეს მოთხოვნები(Interfaces), ხოლო უშუალო იმპლემენტაცია გაკეთებულია Infrastructure ლეიერში, რაც თანხვედრაშია DIP-თან.

Unit of Work პატერნი იმპლემენტირებულია შემდეგნაირად - ყოველ ბაზის თეიბლს აქვს თავისი შესაბამისი რეპოზიტორი, თითოეული რეპოზიტორი პასუხისმგებელია მხოლოდ თავის თეიბლზე და ასრულებს მხოლოდ მარტივ CRUD ოპერაციებს, ნებისმიერი დანარჩენი ბიზნეს ლოგიკა გატანილია რეპოებიდან სერვისებში. 

სერვისები რეპოებთან ნებისმიერ ინტერაქციას ამყარებენ UnitOfWork-ის გავლით, ის ამენეჯებს როგორც რეპოებს, ასევე ბაზის კონტექსტს, სწორედ ამიტომ, ყოველი ენდფოინთის გამოძახების ჭრილში ან ბაზასთან ყველა ინტერაქცია წარმატებით შესრულდება, ან არცერთი, რადგან SaveChanges-ის გამოძახება მკაცრად ხდება მხოლოდ UnitOfWork-დან და არა თითოეული რეპოზიტორიებიდან,

UnitOfWork არის პასუხისმგებელი იმაზე, რომ ერთი რიქვესტის ჭრილში ყველა რეპოზიტორი იზიარებდეს ერთ DbContext-ს.

რადგან ყოველი რეპოზიტორი თავის თავზე მხოლოდ მარტივ CRUD ოპერაციებს იღებს, ერთმანეთს გვანან, ამიტომ DRY პრინციპის დაცვით, ლოგიკა რომ არ გამეორდეს, ისინი BaseRepository-ს შვილები არიან.

ყველა თეიბლს აქვს თავისი შესაფერისი რეპოზიტორი, თუმცა კონტროლერებში და სერვისებში ასე არაა, ისინი უფრო კონტექსტის მიხედვით არიან დაყოფილები:
- **Auth კონტროლერი და სერვისი** პასუხისმგებელია რეგისტრაციასა და დალოგინებაზე
- **User კონტროლერი და სერვისი** დალოგინებული იუზერის ინფოს წამოღებაზე, შეცვლასა და წაშლაზე, ხოლო
- **Admin კონტროლერი და სერვისი** უფრო პრივილეგირებულ ფუნქციონალს მოიცავს, როგორიცაა ყველა იუზერზე ინფორმაციის წამოღება, იუზერის გაადმინება, წაშლა ა.შ..

პაროლები იჰეშება **BCrpyt**-ის გამოყენებით, ავთენთიფიკაციისთვის გამოყენებულია **JWT** ტოკენები რომლის კონფიგურაცია appsetting-ებშია გატანილი, სვაგერზე არის მეთოდების აღწერები და სამაგალითო რიქვესტები.
ლოგირებისთვის გამოყენებულია **Serilog** რომელიც ამჟამინდელი კონფიგურაციით სოლუშენში Logs ფოლდერს ქმნის და იქ ყრის ლოგებს, მოდელებს ადევთ ვალიდაციები **FluentValidation**-ის გამოყენებით, ასევე სოლუშენში არის **Global Exception Handling.**
მთელი სოლუშენი არის ასინქრონული, **ORM**-ად იყენებს **EFCore**-ს, ბაზად **MSSQL**-ს.


## გამოყენების მაგალითი
პირველ რიგში დაკლონვის შემდეგ, **Update-Database** კომანდი უნდა გავუშვათ, რათა მიგრაციები გადატარდეს და ბაზა შეიქმნას. ბაზის ქონექშენსტრინგი გაწერილია appsettings-ში, დეფოლტად სერვერად მითითებულია** (localdb)\MSSQLLocalDB**

გვაქვს სულ სამი თეიბლი - **Users, Roles, და Junction table - UserRoles.**

მათი აიდები არის Guid ტიპის და დაგენერირება ხდება კოდში, არ ამენეჯებს ბაზა, რადგან მაგალითად ახალი User-ის შექმნისას, ჩანაწერი უნდა გაკეთდეს როგორც Users, ისე UserRoles თეიბლში, სანამ UserRoles თეიბლში ჩავაინსერტებთ, UserId უნდა ვიცოდეთ, რასაც ბაზა SaveChanges გამოძახების შემდეგ აგენერირებს.

გამოდის რომ SaveChanges მაგ დროს ორჯერ უნდა გამოგვეძახა რაც UnitOfWork პატერნს დამირღვევდა, ამიტომ მივიღე გადაწყვეტილება გამეხადა ისინი Guid ტიპის.

სოლუშენის გაშვებისას, უნდა გავიაროთ რეგისტრაცია **Auth/Register** ენდფოინთზე, უნდა შევიყვანოთ ვალიდური მონაცემები და შემდეგ 
დავლოგინდეთ **Auth/Login** ენდფოინთით, რომელიც **JWT**-ს დაგვიბრუნებს, ამით ავტორიზაცია უნდა გავიაროთ, სვაგერის ავტორიზაციაში ჯერ ჩავწერთ სიტყვა **bearer**-ს, შემდეგ ტოკენს.

ამის შემდეგ User კონტროლერის ენდფოინთებზე გვექნება წვდომა. 

რაც შეეხება Admin-ის ენდფოინთებს, Seed-ინგის გამოყენებით დასიდულია ერთი იუზერი და ერთი ადმინი
```json
    User
     UserName: "User"
     Email: "User@gmail.com"
     Password:"User123!"
```
 ```json
   Admin
     UserName: "Admin"
     Email: "Admin@gmail.com"
     Password: "Admin123!"
```

თუ დავლოგინდებით მოცემული ადმინ იუზერით, გვექნება Admin ენდფოინთებზეც წვდომა.